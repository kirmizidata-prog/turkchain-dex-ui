import { createPublicClient, http, parseAbiItem, type Address } from "viem";
import fs from "node:fs";
import path from "node:path";

function normAddr(a: any): string {
  if (typeof a !== "string") return "";
  const x = a.trim();
  if (!x.startsWith("0x") || x.length !== 42) return "";
  return x.toLowerCase();
}

function isAddr(a: any): boolean {
  return typeof a === "string" && a.startsWith("0x") && a.length === 42;
}

const CHAIN_ID = 1919;

const RPC_URL = process.env.RPC_URL;
if (!RPC_URL) {
  console.error("missing_env_RPC_URL");
  process.exit(1);
}

const FACTORY = process.env.FACTORY as Address | undefined;
if (!FACTORY || !FACTORY.startsWith("0x") || FACTORY.length !== 42) {
  console.error("missing_or_invalid_env_FACTORY");
  process.exit(1);
}

const OUT_FILE = process.env.OUT_FILE || "/root/turkchain-dex-ui/apps/web/public/pairs.json";
const STATE_FILE = process.env.STATE_FILE || "/root/turkchain-dex-ui/apps/indexer/state.json";

// optional tuning
const START_BLOCK = BigInt(process.env.START_BLOCK || "1");
let chunk = BigInt(process.env.CHUNK || "20000");
type PairRow = { pair: Address; token0: Address; token1: Address };

function readState(): { lastScannedBlock: string } {
  try {
    const raw = fs.readFileSync(STATE_FILE, "utf8");
    const j = JSON.parse(raw);
    if (typeof j.lastScannedBlock === "string") return { lastScannedBlock: j.lastScannedBlock };
  } catch {}
  return { lastScannedBlock: START_BLOCK.toString() };
}

function writeState(lastScannedBlock: bigint) {
  fs.mkdirSync(path.dirname(STATE_FILE), { recursive: true });
  fs.writeFileSync(STATE_FILE, JSON.stringify({ lastScannedBlock: lastScannedBlock.toString() }, null, 2));
}

function writePairs(pairs: PairRow[], updatedAtIso: string) {
  const payload = {
    chainId: CHAIN_ID,
    factory: FACTORY,
    updatedAt: updatedAtIso,
    pairs
  };
  fs.mkdirSync(path.dirname(OUT_FILE), { recursive: true });
  fs.writeFileSync(OUT_FILE, JSON.stringify(payload, null, 2));
}

async function main() {
  const client = createPublicClient({ transport: http(RPC_URL) });

  const latest = await client.getBlockNumber();

  const st = readState();
  let fromBlock = BigInt(st.lastScannedBlock);

  if (fromBlock < START_BLOCK) fromBlock = START_BLOCK;
  if (fromBlock > latest) fromBlock = latest;

  const event = parseAbiItem("event PairCreated(address indexed token0, address indexed token1, address pair, uint256)");

  // load existing pairs.json (append mode)
  let existing: PairRow[] = [];
  try {
    const raw = fs.readFileSync(OUT_FILE, "utf8");
    const j = JSON.parse(raw);
    if (Array.isArray(j.pairs)) existing = j.pairs as PairRow[];
  } catch {}

  const seen = new Set(existing.map((p: any) => normAddr(p.pair)));
  const out: PairRow[] = [...existing];

  console.log(`latest_block=${latest.toString()}`);
  console.log(`from_block=${fromBlock.toString()}`);
  console.log("chunk=" + chunk.toString());

  let cursor = fromBlock;
  while (cursor <= latest) {
    let logs = [];
    let toBlock = cursor + chunk - 1n <= latest ? cursor + chunk - 1n : latest;

    while (true) {
      try {
        toBlock = cursor + chunk - 1n <= latest ? cursor + chunk - 1n : latest;
        logs = await client.getLogs({
          address: FACTORY,
          event,
          fromBlock: cursor,
          toBlock
        });
        break;
      } catch (err) {
        const msg = String(err?.shortMessage || err?.message || err);
        const m = msg.toLowerCase();
        const looksLikeParam = m.includes("invalid") || m.includes("missing") || msg.includes("-32602");
        if (looksLikeParam && chunk > 1000n) {
          chunk = chunk / 2n;
          console.log("getLogs_retry_shrink_chunk=" + chunk.toString());
          continue;
        }
        throw err;
      }
    }

    for (const lg of logs) {
      const args: any = lg.args;
      const pair = args.pair as Address;
      const token0 = args.token0 as Address;
      const token1 = args.token1 as Address;

      const key = normAddr(pair);
    if (!key) {
      continue;
    }
      if (seen.has(key)) continue;

      seen.add(key);
      out.push({ pair, token0, token1 });
    }

    console.log(`scanned=${cursor.toString()}..${toBlock.toString()} logs=${logs.length} pairs_total=${out.length}`);

    cursor = toBlock + 1n;
    writeState(cursor);
  }

  writePairs(out, new Date().toISOString());
  console.log(`done pairs_total=${out.length} out=${OUT_FILE}`);
}

main().catch((e) => {
  console.error("fatal", e?.shortMessage || e?.message || e);
  process.exit(1);
});
