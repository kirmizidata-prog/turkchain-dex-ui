"use client";

import * as React from "react";
import WalletButton from "@/components/WalletButton";
import { contracts } from "@/lib/turkchain";
import { erc20Abi, routerV2Abi } from "@/lib/abis";
import { publicClient, getWalletClient } from "@/lib/evm";
import { useWallet } from "@/lib/useWallet";
import { loadTokenList, type TokenInfo } from "@/lib/tokenlist";
import { formatUnits, parseUnits, type Address, isAddress, zeroAddress } from "viem";

const TURKSCAN_TX = "https://turkscan.com/tx/";

const factoryAbi = [
  {
    type: "function",
    name: "getPair",
    stateMutability: "view",
    inputs: [
      { name: "tokenA", type: "address" },
      { name: "tokenB", type: "address" }
    ],
    outputs: [{ name: "pair", type: "address" }]
  }
] as const;

const pairAbi = [
  {
    type: "function",
    name: "token0",
    stateMutability: "view",
    inputs: [],
    outputs: [{ name: "", type: "address" }]
  },
  {
    type: "function",
    name: "token1",
    stateMutability: "view",
    inputs: [],
    outputs: [{ name: "", type: "address" }]
  },
  {
    type: "function",
    name: "getReserves",
    stateMutability: "view",
    inputs: [],
    outputs: [
      { name: "reserve0", type: "uint112" },
      { name: "reserve1", type: "uint112" },
      { name: "blockTimestampLast", type: "uint32" }
    ]
  }
] as const;

function applySlippage(amountOut: bigint, bps: number) {
  return (amountOut * BigInt(10000 - bps)) / BigInt(10000);
}

function shortAddr(a: string) {
  if (!a) return "-";
  return a.slice(0, 6) + "..." + a.slice(-4);
}

function bnMaxUint256() {
  return (1n << 256n) - 1n;
}

function bnTwoPow255() {
  return 1n << 255n;
}

function formatAllowance(allow: bigint | null, decimals: number) {
  if (allow === null) return "-";
  if (allow >= bnTwoPow255()) return "Unlimited";
  return formatUnits(allow, decimals);
}


// UniswapV2 amountOut formula (fee 0.3% -> 997/1000)
function calcAmountOut(amountIn: bigint, reserveIn: bigint, reserveOut: bigint) {
  if (amountIn <= 0n) return 0n;
  if (reserveIn <= 0n || reserveOut <= 0n) return 0n;
  const amountInWithFee = amountIn * 997n;
  const numerator = amountInWithFee * reserveOut;
  const denominator = reserveIn * 1000n + amountInWithFee;
  if (denominator === 0n) return 0n;
  return numerator / denominator;
}

function calcPriceImpactBps(amountIn: bigint, amountOut: bigint, reserveIn: bigint, reserveOut: bigint) {
  // priceImpact = (midPrice - execPrice) / midPrice
  // midPrice = reserveOut / reserveIn
  // execPrice = amountOut / amountIn (out per in)
  // Use bps with integer math:
  // impact = 1 - (amountOut * reserveIn) / (amountIn * reserveOut)
  if (amountIn <= 0n || amountOut <= 0n) return 0;
  if (reserveIn <= 0n || reserveOut <= 0n) return 0;

  const left = amountOut * reserveIn; // out * reserveIn
  const right = amountIn * reserveOut; // in * reserveOut
  if (right === 0n) return 0;

  // ratio = left/right. impact = 1 - ratio.
  // bps = (1 - ratio) * 10000
  // => bps = (right - left) * 10000 / right
  if (left >= right) return 0;
  const bps = Number(((right - left) * 10000n) / right);
  return Math.max(0, Math.min(10000, bps));
}

export default function SwapPage() {
  const { address, chainId } = useWallet();

  const [tokenList, setTokenList] = React.useState<TokenInfo[]>([]);
  const [inToken, setInToken] = React.useState<TokenInfo | null>(null);
  const [outToken, setOutToken] = React.useState<TokenInfo | null>(null);

  const [amountInStr, setAmountInStr] = React.useState("0.1");
  const [quoteOut, setQuoteOut] = React.useState<bigint | null>(null);

  const [balIn, setBalIn] = React.useState<bigint | null>(null);
  const [balOut, setBalOut] = React.useState<bigint | null>(null);
  const [allowIn, setAllowIn] = React.useState<bigint | null>(null);

  const [slippageBps, setSlippageBps] = React.useState(100); // 1.00%
  const [useMaxApproval, setUseMaxApproval] = React.useState(true);

  const [minOut, setMinOut] = React.useState<bigint | null>(null);
  const [priceImpactBps, setPriceImpactBps] = React.useState<number | null>(null);
  const [isQuoting, setIsQuoting] = React.useState<boolean>(false);
  const [confirmHighImpact, setConfirmHighImpact] = React.useState<boolean>(false);

  const [txHash, setTxHash] = React.useState<string>("");
  const [status, setStatus] = React.useState<string>("");
  const [isPending, setIsPending] = React.useState<boolean>(false);

  React.useEffect(() => {
    (async () => {
      try {
        const list = await loadTokenList();
        setTokenList(list);
        if (list.length >= 2) {
          setInToken(list[0]);
          setOutToken(list[1]);
        } else if (list.length === 1) {
          setInToken(list[0]);
        }
      } catch (e: any) {
        setStatus(e?.message || "tokenlist_load_failed");
      }
    })();
  }, []);

  async function refreshWallet() {
    try {
      if (!address || !isAddress(address) || !inToken || !outToken) {
        setBalIn(null);
        setBalOut(null);
        setAllowIn(null);
        return;
      }

      const [bIn, bOut, aIn] = await Promise.all([
        publicClient.readContract({
          address: inToken.address,
          abi: erc20Abi,
          functionName: "balanceOf",
          args: [address as Address]
        }),
        publicClient.readContract({
          address: outToken.address,
          abi: erc20Abi,
          functionName: "balanceOf",
          args: [address as Address]
        }),
        publicClient.readContract({
          address: inToken.address,
          abi: erc20Abi,
          functionName: "allowance",
          args: [address as Address, contracts.router]
        })
      ]);

      setBalIn(bIn as bigint);
      setBalOut(bOut as bigint);
      setAllowIn(aIn as bigint);
    } catch (e: any) {
      setStatus(e?.shortMessage || e?.message || "wallet_refresh_failed");
    }
  }

  async function fetchQuoteAndMetrics() {
    setStatus("");
    setTxHash("");
    setQuoteOut(null);
    setMinOut(null);
    setPriceImpactBps(null);
    setConfirmHighImpact(false);
    setIsQuoting(true);

    try {
      if (!inToken || !outToken) return;
      if (inToken.address.toLowerCase() === outToken.address.toLowerCase()) {
        setStatus("same_token");
        return;
      }

      const amountIn = parseUnits(amountInStr || "0", inToken.decimals);
      if (amountIn <= 0n) return;

      const amounts = await publicClient.readContract({
        address: contracts.router,
        abi: routerV2Abi,
        functionName: "getAmountsOut",
        args: [amountIn, [inToken.address, outToken.address]]
      });

      const out = (amounts as readonly bigint[])[1] ?? 0n;
      setQuoteOut(out);

      const mo = applySlippage(out, slippageBps);
      setMinOut(mo);

            <div className="opacity-80">
              Price impact:{" "}
              {priceImpactBps === null ? "-" : (priceImpactBps / 100).toFixed(2) + "%"}
            </div>
            {priceImpactBps !== null && priceImpactBps >= 500 ? (
              <div className="mt-1 flex items-center gap-2 text-xs">
                <span className="text-red-600">High price impact warning</span>
                {confirmHighImpact ? (
                  <button
                    className="rounded-lg border px-2 py-1"
                    onClick={() => {
                      setConfirmHighImpact(false);
                      setStatus("");
                    }}
                  >
                    Cancel
                  </button>
                ) : null}
              </div>
            ) : null}
            <div className="opacity-80">
              Route:{" "}
              {inToken?.symbol ?? "?"} {"->"} {outToken?.symbol ?? "?"}
            </div>
          </div>

          <div className="flex gap-2">
            <button
              className="rounded-xl border px-4 py-2 text-sm"
              onClick={() => {
                const a = inToken;
                const b = outToken;
                setInToken(b);
                setOutToken(a);
              }}
            >
              Flip
            </button>

            <button
              className={"rounded-xl border px-4 py-2 text-sm " + ((!needApprove || isPending) ? "opacity-50 cursor-not-allowed" : "")}
              onClick={doApprove}
              disabled={!needApprove || isPending}
              title={needApprove ? "Approve token" : "No approval needed"}
            >
              Approve
            </button>

            <button
              className={"ml-auto rounded-xl bg-black px-4 py-2 text-sm text-white " + (!canSwap ? "opacity-50 cursor-not-allowed" : "")}
              onClick={doSwap}
              disabled={!canSwap}
              title={needApprove ? "Approve first" : "Swap"}
            >
              {confirmHighImpact ? "Swap anyway" : "Swap"}
            </button>
          </div>

          <button
            className="rounded-xl border px-4 py-2 text-sm"
            onClick={async () => {
              await refreshWallet();
              await fetchQuoteAndMetrics();
            }}
          >
            Refresh
          </button>
        </div>

        {txHash ? (
          <div className="mt-4 rounded-xl border p-3 text-xs opacity-80">
            Tx:{" "}
            <a className="underline" target="_blank" rel="noreferrer" href={TURKSCAN_TX + txHash}>
              {shortAddr(txHash)}
            </a>
          </div>
        ) : null}

        {statusLabel ? (
          <div className="mt-3 rounded-xl border p-3 text-xs opacity-80">Status: {statusLabel}</div>
        ) : null}
      </div>
    </main>
  );
}
