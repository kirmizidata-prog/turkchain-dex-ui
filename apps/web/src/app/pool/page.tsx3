"use client";

import * as React from "react";
import WalletButton from "@/components/WalletButton";
import { contracts } from "@/lib/turkchain";
import { erc20Abi, pairAbi, routerV2Abi, factoryAbi } from "@/lib/abis";
import { formatUnits, parseUnits, type Address, zeroAddress, isAddress } from "viem";
import { publicClient, getWalletClient } from "@/lib/evm";
import { useWallet } from "@/lib/useWallet";
import { useRouter, useSearchParams } from "next/navigation";
import { loadTokenList, type TokenInfo } from "@/lib/tokenlist";

function applySlippage(x: bigint, bps: number) {
  return (x * BigInt(10000 - bps)) / BigInt(10000);
}

type Tab = "ADD" | "REMOVE";

async function fetchTokenInfo(addr: Address): Promise<TokenInfo> {
  const [sym, dec] = await Promise.all([
    publicClient.readContract({ address: addr, abi: erc20Abi, functionName: "symbol" }).catch(() => ""),
    publicClient.readContract({ address: addr, abi: erc20Abi, functionName: "decimals" }).catch(() => 18)
  ]);

  const symbol = typeof sym === "string" && sym.length ? sym : addr.slice(0, 6) + "..." + addr.slice(-4);
  const decimals = Number(dec) || 18;

  return {
    chainId: 1919,
    address: addr,
    symbol,
    decimals
  };
}

export default function PoolPage() {
  const { address, chainId } = useWallet();
  const router = useRouter();
  const sp = useSearchParams();

  const [tab, setTab] = React.useState<Tab>("ADD");
  const [slippageBps, setSlippageBps] = React.useState(100);

  const [tokenList, setTokenList] = React.useState<TokenInfo[]>([]);
  const [tokenA, setTokenA] = React.useState<TokenInfo | null>(null);
  const [tokenB, setTokenB] = React.useState<TokenInfo | null>(null);

  const [pair, setPair] = React.useState<Address | null>(null);
  const [pairPinned, setPairPinned] = React.useState<boolean>(false);
  const [pairStatus, setPairStatus] = React.useState<string>("");

  const [amountAStr, setAmountAStr] = React.useState("0.1");
  const [amountBStr, setAmountBStr] = React.useState("");

  const [status, setStatus] = React.useState("");

  const [reserveA, setReserveA] = React.useState<bigint | null>(null);
  const [reserveB, setReserveB] = React.useState<bigint | null>(null);
  const [token0, setToken0] = React.useState<Address | null>(null);

  const [balA, setBalA] = React.useState<bigint | null>(null);
  const [balB, setBalB] = React.useState<bigint | null>(null);
  const [allowA, setAllowA] = React.useState<bigint | null>(null);
  const [allowB, setAllowB] = React.useState<bigint | null>(null);

  const [lpBal, setLpBal] = React.useState<bigint | null>(null);
  const [lpAllow, setLpAllow] = React.useState<bigint | null>(null);
  const [lpTotal, setLpTotal] = React.useState<bigint | null>(null);

  const [removePct, setRemovePct] = React.useState(25);

  // Load token list + seed from URL
  React.useEffect(() => {
    (async () => {
      try {
        const list = await loadTokenList();
        setTokenList(list);

        const qPair = sp.get("pair");
        const qA = sp.get("tokenA");
        const qB = sp.get("tokenB");

        // If pair is pinned: read token0/token1 from pair and lock selectors
        if (qPair && isAddress(qPair)) {
          const pinned = qPair as Address;
          setPair(pinned);
          setPairPinned(true);
          setPairStatus("pair_pinned_by_query");

          const [t0, t1] = await Promise.all([
            publicClient.readContract({ address: pinned, abi: pairAbi, functionName: "token0" }),
            publicClient.readContract({ address: pinned, abi: pairAbi, functionName: "token1" })
          ]);

          const token0Addr = t0 as Address;
          const token1Addr = t1 as Address;

          const inList0 = list.find((x) => x.address.toLowerCase() === token0Addr.toLowerCase()) || null;
          const inList1 = list.find((x) => x.address.toLowerCase() === token1Addr.toLowerCase()) || null;

          const resolved0 = inList0 || (await fetchTokenInfo(token0Addr));
          const resolved1 = inList1 || (await fetchTokenInfo(token1Addr));

          setTokenA(resolved0);
          setTokenB(resolved1);

          const qs = new URLSearchParams();
          qs.set("pair", pinned);
          qs.set("tokenA", token0Addr);
          qs.set("tokenB", token1Addr);
          router.replace(`/pool?${qs.toString()}`);
          return;
        }

        // Non pinned mode: seed tokenA/tokenB from tokenA/tokenB query
        if (qA && isAddress(qA)) {
          const t = list.find((x) => x.address.toLowerCase() === qA.toLowerCase());
          if (t) setTokenA(t);
        }
        if (qB && isAddress(qB)) {
          const t = list.find((x) => x.address.toLowerCase() === qB.toLowerCase());
          if (t) setTokenB(t);
        }

        // Default if none
        if (!qA && !qB && list.length >= 2) {
          setTokenA(list[0]);
          setTokenB(list[1]);
        }
      } catch (e: any) {
        setStatus(e?.message || "tokenlist_load_failed");
      }
    })();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Resolve pair from factory (only if NOT pinned)
  React.useEffect(() => {
    (async () => {
      try {
        if (pairPinned) return;
        if (!tokenA || !tokenB) return;

        if (tokenA.address.toLowerCase() === tokenB.address.toLowerCase()) {
          setPair(null);
          setPairStatus("same_token");
          return;
        }

        setPairStatus("resolving_pair");
        const p = await publicClient.readContract({
          address: contracts.factory,
          abi: factoryAbi,
          functionName: "getPair",
          args: [tokenA.address, tokenB.address]
        });

        const addr = p as Address;
        if (!addr || addr === zeroAddress) {
          setPair(null);
          setPairStatus("pair_not_found_will_create_on_add");
        } else {
          setPair(addr);
          setPairStatus("pair_ok");
        }

        const qs = new URLSearchParams();
        qs.set("tokenA", tokenA.address);
        qs.set("tokenB", tokenB.address);
        router.replace(`/pool?${qs.toString()}`);
      } catch (e: any) {
        setPair(null);
        setPairStatus(e?.shortMessage || e?.message || "pair_resolve_failed");
      }
    })();
  }, [tokenA, tokenB, pairPinned, router]);

  async function refreshReserves() {
    try {
      if (!pair || !tokenA || !tokenB) return;

      const [t0, reserves] = await Promise.all([
        publicClient.readContract({ address: pair, abi: pairAbi, functionName: "token0" }),
        publicClient.readContract({ address: pair, abi: pairAbi, functionName: "getReserves" })
      ]);

      const r = reserves as readonly [bigint, bigint, number];
      const _token0 = t0 as Address;
      setToken0(_token0);

      const aIs0 = _token0.toLowerCase() === tokenA.address.toLowerCase();
      const rA = aIs0 ? (r[0] as bigint) : (r[1] as bigint);
      const rB = aIs0 ? (r[1] as bigint) : (r[0] as bigint);

      setReserveA(rA);
      setReserveB(rB);
    } catch (e: any) {
      setStatus(e?.shortMessage || e?.message || "reserves_failed");
    }
  }

  async function refreshWalletState() {
    try {
      if (!address || !pair || !tokenA || !tokenB) {
        setBalA(null);
        setBalB(null);
        setAllowA(null);
        setAllowB(null);
        setLpBal(null);
        setLpAllow(null);
        setLpTotal(null);
        return;
      }

      const [bA, bB, aA, aB, lpb, lpa, lpt] = await Promise.all([
        publicClient.readContract({ address: tokenA.address, abi: erc20Abi, functionName: "balanceOf", args: [address] }),
        publicClient.readContract({ address: tokenB.address, abi: erc20Abi, functionName: "balanceOf", args: [address] }),
        publicClient.readContract({ address: tokenA.address, abi: erc20Abi, functionName: "allowance", args: [address, contracts.router] }),
        publicClient.readContract({ address: tokenB.address, abi: erc20Abi, functionName: "allowance", args: [address, contracts.router] }),
        publicClient.readContract({ address: pair, abi: pairAbi, functionName: "balanceOf", args: [address] }),
        publicClient.readContract({ address: pair, abi: pairAbi, functionName: "allowance", args: [address, contracts.router] }),
        publicClient.readContract({ address: pair, abi: pairAbi, functionName: "totalSupply" })
      ]);

      setBalA(bA as bigint);
      setBalB(bB as bigint);
      setAllowA(aA as bigint);
      setAllowB(aB as bigint);

      setLpBal(lpb as bigint);
      setLpAllow(lpa as bigint);
      setLpTotal(lpt as bigint);
    } catch (e: any) {
      setStatus(e?.shortMessage || e?.message || "wallet_state_failed");
    }
  }

  React.useEffect(() => {
    refreshReserves();
    refreshWalletState();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [pair, address, tokenA?.address, tokenB?.address]);

  function computeBfromA(aStr: string) {
    try {
      if (!reserveA || !reserveB || !tokenA || !tokenB) return "";
      const a = parseUnits(aStr || "0", tokenA.decimals);
      if (a <= 0n) return "";
      const b = (a * reserveB) / reserveA;
      return formatUnits(b, tokenB.decimals);
    } catch {
      return "";
    }
  }

  async function approveIfNeeded(tokenAddr: Address, current: bigint | null, needed: bigint) {
    if (!address) throw new Error("connect_wallet");
    if (chainId !== 1919) throw new Error("wrong_network");
    if ((current ?? 0n) >= needed) return;

    const wc = getWalletClient();
    if (!wc) throw new Error("no_wallet_client");

    const hash = await wc.writeContract({
      address: tokenAddr,
      abi: erc20Abi,
      functionName: "approve",
      args: [contracts.router, needed],
      account: address as Address
    });

    await publicClient.waitForTransactionReceipt({ hash });
  }

  async function doAdd() {
    setStatus("");
    try {
      if (!address) return setStatus("connect_wallet");
      if (chainId !== 1919) return setStatus("wrong_network");
      if (!tokenA || !tokenB) return setStatus("select_tokens");

      const amountADesired = parseUnits(amountAStr || "0", tokenA.decimals);
      if (amountADesired <= 0n) return setStatus("invalid_amount_a");

      const amountBDesired = parseUnits(amountBStr || computeBfromA(amountAStr) || "0", tokenB.decimals);
      if (amountBDesired <= 0n) return setStatus("invalid_amount_b");

      if (balA !== null && balA < amountADesired) return setStatus("insufficient_balance_a");
      if (balB !== null && balB < amountBDesired) return setStatus("insufficient_balance_b");

      setStatus("approving...");
      await approveIfNeeded(tokenA.address, allowA, amountADesired);
      await approveIfNeeded(tokenB.address, allowB, amountBDesired);

      const amountAMin = applySlippage(amountADesired, slippageBps);
      const amountBMin = applySlippage(amountBDesired, slippageBps);
      const deadline = BigInt(Math.floor(Date.now() / 1000) + 600);

      const wc = getWalletClient();
      if (!wc) throw new Error("no_wallet_client");

      setStatus("adding_liquidity...");
      const hash = await wc.writeContract({
        address: contracts.router,
        abi: routerV2Abi,
        functionName: "addLiquidity",
        args: [
          tokenA.address,
          tokenB.address,
          amountADesired,
          amountBDesired,
          amountAMin,
          amountBMin,
          address as Address,
          deadline
        ],
        account: address as Address
      });

      const receipt = await publicClient.waitForTransactionReceipt({ hash });
      setStatus(receipt.status === "success" ? "add_success" : "add_failed");

      if (!pairPinned) {
        const p = await publicClient.readContract({
          address: contracts.factory,
          abi: factoryAbi,
          functionName: "getPair",
          args: [tokenA.address, tokenB.address]
        });
        const addr = p as Address;
        if (addr && addr !== zeroAddress) setPair(addr);
      }

      await refreshReserves();
      await refreshWalletState();
    } catch (e: any) {
      setStatus(e?.shortMessage || e?.message || "add_error");
    }
  }

  async function doRemove() {
    setStatus("");
    try {
      if (!address) return setStatus("connect_wallet");
      if (chainId !== 1919) return setStatus("wrong_network");
      if (!tokenA || !tokenB) return setStatus("select_tokens");
      if (!pair) return setStatus("no_pair");
      if (!lpBal || lpBal <= 0n) return setStatus("no_lp_balance");
      if (!reserveA || !reserveB || !lpTotal || lpTotal <= 0n) return setStatus("no_pool_state");

      const liquidity = (lpBal * BigInt(removePct)) / BigInt(100);
      if (liquidity <= 0n) return setStatus("invalid_liquidity");

      const expectedA = (liquidity * reserveA) / lpTotal;
      const expectedB = (liquidity * reserveB) / lpTotal;

      const amountAMin = applySlippage(expectedA, slippageBps);
      const amountBMin = applySlippage(expectedB, slippageBps);
      const deadline = BigInt(Math.floor(Date.now() / 1000) + 600);

      const wc = getWalletClient();
      if (!wc) throw new Error("no_wallet_client");

      if ((lpAllow ?? 0n) < liquidity) {
        setStatus("approving_lp...");
        const h1 = await wc.writeContract({
          address: pair,
          abi: pairAbi,
          functionName: "approve",
          args: [contracts.router, liquidity],
          account: address as Address
        });
        await publicClient.waitForTransactionReceipt({ hash: h1 });
      }

      setStatus("removing_liquidity...");
      const hash = await wc.writeContract({
        address: contracts.router,
        abi: routerV2Abi,
        functionName: "removeLiquidity",
        args: [
          tokenA.address,
          tokenB.address,
          liquidity,
          amountAMin,
          amountBMin,
          address as Address,
          deadline
        ],
        account: address as Address
      });

      const receipt = await publicClient.waitForTransactionReceipt({ hash });
      setStatus(receipt.status === "success" ? "remove_success" : "remove_failed");

      await refreshReserves();
      await refreshWalletState();
    } catch (e: any) {
      setStatus(e?.shortMessage || e?.message || "remove_error");
    }
  }

  const poolLabel = tokenA && tokenB ? `${tokenA.symbol} / ${tokenB.symbol}` : "Pool";

  const lpSharePct =
    lpBal && lpTotal && lpTotal > 0n ? Number((lpBal * 10000n) / lpTotal) / 100 : null;

  return (
    <main className="min-h-screen flex items-center justify-center p-6">
      <div className="w-full max-w-2xl rounded-2xl border p-6 shadow-sm">
        <div className="flex items-start justify-between gap-4">
          <div>
            <h1 className="text-xl font-semibold">Pool</h1>
            <div className="mt-1 text-xs opacity-70">{poolLabel}</div>
            <div className="mt-1 text-xs opacity-70">Factory: {contracts.factory}</div>
            <div className="mt-1 text-xs opacity-70">Pair: {pair ? pair : "(not resolved)"}</div>
            {pairStatus ? <div className="mt-1 text-xs opacity-70">Pair status: {pairStatus}</div> : null}
            {pairPinned ? <div className="mt-1 text-xs opacity-70">Mode: pinned_by_pair_query</div> : null}
          </div>
          <WalletButton />
        </div>

        <div className="mt-6 grid grid-cols-1 gap-3 md:grid-cols-2">
          <div>
            <label className="text-xs opacity-70">Token A</label>
            <select
              className="mt-1 w-full rounded-xl border px-3 py-2"
              value={tokenA?.address ?? ""}
              disabled={pairPinned}
              onChange={(e) => {
                const t = tokenList.find((x) => x.address === (e.target.value as Address));
                setTokenA(t ?? null);
              }}
            >
              <option value="" disabled>
                Select token
              </option>
              {tokenList.map((t) => (
                <option key={t.address} value={t.address}>
                  {t.symbol} ({t.address.slice(0, 6)}...{t.address.slice(-4)})
                </option>
              ))}
            </select>
          </div>

          <div>
            <label className="text-xs opacity-70">Token B</label>
            <select
              className="mt-1 w-full rounded-xl border px-3 py-2"
              value={tokenB?.address ?? ""}
              disabled={pairPinned}
              onChange={(e) => {
                const t = tokenList.find((x) => x.address === (e.target.value as Address));
                setTokenB(t ?? null);
              }}
            >
              <option value="" disabled>
                Select token
              </option>
              {tokenList.map((t) => (
                <option key={t.address} value={t.address}>
                  {t.symbol} ({t.address.slice(0, 6)}...{t.address.slice(-4)})
                </option>
              ))}
            </select>
          </div>
        </div>

        <div className="mt-6 flex gap-2">
          <button
            className={`rounded-xl border px-4 py-2 ${tab === "ADD" ? "bg-black text-white" : ""}`}
            onClick={() => setTab("ADD")}
          >
            Add
          </button>
          <button
            className={`rounded-xl border px-4 py-2 ${tab === "REMOVE" ? "bg-black text-white" : ""}`}
            onClick={() => setTab("REMOVE")}
          >
            Remove
          </button>
          <button
            className="ml-auto rounded-xl border px-4 py-2"
            onClick={async () => {
              setStatus("");
              await refreshReserves();
              await refreshWalletState();
            }}
          >
            Refresh
          </button>
        </div>

        {pair && reserveA !== null && reserveB !== null && tokenA && tokenB ? (
          <div className="mt-4 rounded-xl border p-4 text-sm">
            <div className="opacity-80">
              Reserves: {formatUnits(reserveA, tokenA.decimals)} {tokenA.symbol} /{" "}
              {formatUnits(reserveB, tokenB.decimals)} {tokenB.symbol}
            </div>
            {lpSharePct !== null ? <div className="mt-1 opacity-80">Your LP share: ~{lpSharePct}%</div> : null}
            {token0 ? <div className="mt-1 text-xs opacity-70">Pair token0: {token0}</div> : null}
          </div>
        ) : (
          <div className="mt-4 rounded-xl border p-4 text-sm opacity-80">
            Pool reserves not available yet. If pair does not exist, first addLiquidity will create it.
          </div>
        )}

        <div className="mt-6 space-y-3">
          <div>
            <label className="text-xs opacity-70">Slippage (%)</label>
            <input
              className="mt-1 w-full rounded-xl border px-3 py-2"
              value={String(slippageBps / 100)}
              onChange={(e) => {
                const v = Number(e.target.value || "1");
                const bps = Math.max(0, Math.min(500, Math.floor(v * 100)));
                setSlippageBps(bps);
              }}
            />
          </div>

          {tab === "ADD" ? (
            <>
              <div>
                <label className="text-xs opacity-70">Amount A ({tokenA?.symbol ?? "TokenA"})</label>
                <input
                  className="mt-1 w-full rounded-xl border px-3 py-2"
                  value={amountAStr}
                  onChange={(e) => {
                    const v = e.target.value;
                    setAmountAStr(v);
                    setAmountBStr(computeBfromA(v));
                  }}
                />
                <div className="mt-1 text-xs opacity-70">
                  Balance A: {tokenA && balA !== null ? formatUnits(balA, tokenA.decimals) : "-"}
                </div>
              </div>

              <div>
                <label className="text-xs opacity-70">Amount B ({tokenB?.symbol ?? "TokenB"}) (auto)</label>
                <input
                  className="mt-1 w-full rounded-xl border px-3 py-2"
                  value={amountBStr || computeBfromA(amountAStr)}
                  onChange={(e) => setAmountBStr(e.target.value)}
                />
                <div className="mt-1 text-xs opacity-70">
                  Balance B: {tokenB && balB !== null ? formatUnits(balB, tokenB.decimals) : "-"}
                </div>
              </div>

              <button
                className="mt-2 inline-flex w-full items-center justify-center rounded-xl bg-black px-4 py-2 text-white"
                onClick={doAdd}
              >
                Add Liquidity
              </button>
            </>
          ) : (
            <>
              <div className="rounded-xl border p-4 text-sm">
                <div className="opacity-80">LP balance: {lpBal !== null ? formatUnits(lpBal, 18) : "-"}</div>
                <div className="mt-1 opacity-80">Remove percent: {removePct}%</div>
              </div>

              <input
                className="w-full rounded-xl border px-3 py-2"
                value={String(removePct)}
                onChange={(e) => setRemovePct(Math.max(1, Math.min(100, Number(e.target.value || "25"))))}
              />

              <button
                className="mt-2 inline-flex w-full items-center justify-center rounded-xl bg-black px-4 py-2 text-white"
                onClick={doRemove}
              >
                Remove Liquidity
              </button>
            </>
          )}
        </div>

        {status ? (
          <div className="mt-4 rounded-xl border p-3 text-xs opacity-80">Status: {status}</div>
        ) : null}

        <div className="mt-6 text-xs opacity-60">Router: {contracts.router}</div>
      </div>
    </main>
  );
}
